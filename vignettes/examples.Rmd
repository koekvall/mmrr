---
title: "Latent Variable Multivariate Mixed-type Response Regression"
author: "Karl Oskar Ekvall"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Latent Variable Multivariate Mixed-type Response Regression}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

# Installation

The package can be installed from GitHub, using devtools.

```{r}
  # devtools::install_github("koekvall/lvmmrPQL") 
```


# Notation

The matrix of responses, $Y$, has $n$ rows and $r$ columns. The matrix of predictors, $X$, has $nr$ rows and $p$ columns; the first $r$ rows of $X$ are the design matrix for the $r$ responses in the first row of $Y$, the next $r$ rows of $X$ are the design matrix for the second row of $Y$, and so on. Thus, \texttt{matrix(X %*% Beta, nrow = n, ncol = r, byrow = TRUE)} gives an $n\times r$ matrix whose $i$th row is the mean of the $i$th latent vector.

# Example with normal responses
```{r}
set.seed(4)
n <- 100
type <- rep(1, 1) # Only normal responses
r <- length(type)

# Each observation has its own intercept
X <- Matrix::kronecker(rep(1, n), diag(r))
Beta_true <- (1:r) / r

# Variance parameters, psi treated as known
Sigma_true <- 0.5^abs(outer(1:r, 1:r, FUN = "-"))
psi_true <- rep(0.5, r)

Y <- lvmmrPQL::generate_lvmmr(X = X, Beta = Beta_true, R = chol(Sigma_true),
                    type = type, psi = psi_true)
# No restrictions with normal responses
M <- matrix(NA, r, r)

# Compute MLEs
fit_MLE <- lm(Y ~ 1)
Beta_MLE <- c(coef(fit_MLE))
Sigma_MLE <- crossprod(matrix(residuals(fit_MLE), ncol = r)) / n -
  diag(psi_true, r)

# Does MLE exist? That is, is maximizer PD?
min(eigen(Sigma_MLE)$values)

# Skip W update; obj. fun, does not depend on W with mult. norm. resp.
# MLE of Beta does not depend on Sigma, so expect correct MLE for Beta
# regardless of whether algorithm finds MLE of Sigma.
fit <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = T,
                           quiet = c(T, T, T, T),
                           maxit = c(100, 100, 500, 0),
                           tol = c(1e-12, 1e-8, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = FALSE)
# Difference to MLEs
fit$Beta - Beta_MLE
fit$Sigma - Sigma_MLE


# With MLE as starting value
fit <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = T,
                           quiet = c(F, T, T, T),
                           maxit = c(100, 100, 500, 0),
                           tol = c(1e-12, 1e-8, 1e-12, 1e-8),
                           pgd = FALSE,
                           Beta = Beta_MLE,
                           Sigma = Sigma_MLE,
                           psi = psi_true)
fit$iter
# Difference to MLEs
fit$Beta - Beta_MLE
fit$Sigma - Sigma_MLE

# See that objective is correct
D1 <- t(lvmmrPQL:::get_cumulant_diffs(t(fit$W), type, 1))
D2 <- t(lvmmrPQL:::get_cumulant_diffs(t(fit$W), type, 2))

lvmmrPQL:::working_ll_rcpp(Y_T = t(Y), X_T = t(X), beta = fit$Beta,
                                  Sigma = fit$Sigma, W_T = t(fit$W),
                                  psi = psi_true,
                                  D1_T = t(D1), D2_T = t(D2))

lvmmrPQL:::working_ll_rcpp(Y_T = t(Y), X_T = t(X), beta = Beta_MLE,
                                  Sigma = Sigma_MLE, W_T = t(fit$W),
                                  psi = psi_true,
                                  D1_T = t(D1), D2_T = t(D2))

# Double check w. multivariate normal likelihood
Xb <- matrix(X %*% fit$Beta, nrow = n, ncol = r, byrow = T)
sum(mvtnorm::dmvnorm(x = Y - Xb, sigma = fit$Sigma +
                       diag(psi_true, r), log = TRUE))
sum(mvtnorm::dmvnorm(x = Y - predict(fit_MLE), sigma = Sigma_MLE +
                       diag(psi_true, r), log = TRUE))


```


# Example with mixed-type responses
```{r}
set.seed(40)
n <- 30
type <- c(1, 2, 3)
r <- length(type)


# Each observation has an intercept and two uniform predictor (SUR)
p <- 2
X <- matrix(0, nrow= n * r, ncol = r * ( p + 1))
counter <- 1
for(jj in 1:n){
  for(kk in 1:r){
    X[counter, ((kk - 1) * (p + 1) + 1):(kk * (p + 1))] <- c(1, runif(p, -1, 1))
    counter <- counter + 1
  }
}

Beta_true <- 1.5 * runif((p + 1) * r, -1, 1)

# Variance parameters, psi treated as known
Sigma_true <- matrix(0.999, r, r)
diag(Sigma_true) <- 1
Sigma_true <- 0.1 * Sigma_true
psi_true <- rep(1e-7, r)
psi_true[type == 2] <- 1 # Bernoulli does not support psi

Y <- lvmmrPQL::generate_lvmmr(X = X, Beta = Beta_true, R = chol(Sigma_true),
                    type = type, psi = psi_true)
# No restrictions with normal and Poisson responses
M <- matrix(NA, r, r)
diag(M)[type == 2] <- 1


fit_trust <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = FALSE,
                           quiet = c(F, T, T, T),
                           maxit = c(50, 100, 500, 100),
                           tol = c(1e-5, 1e-7, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = FALSE)
# Use starting values
fit_pgd <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = FALSE,
                           quiet = c(F, F, F, T),
                           maxit = c(50, 100, 500, 100),
                           tol = c(1e-5, 1e-7, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = TRUE,
                           Beta = fit_trust$Beta,
                           Sigma = fit_trust$Sigma,
                           W = fit_trust$W)

# Diagonal
M <- diag(NA, r)
diag(M)[type == 2] <- 1
fit_diag <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = M,
                           relative = FALSE,
                           quiet = c(F, T, T, T),
                           maxit = c(50, 100, 500, 100),
                           tol = c(1e-5, 1e-7, 1e-10, 1e-8),
                           psi = psi_true,
                           pgd = TRUE,
                           Beta = fit_trust$Beta,
                           Sigma = diag(diag(fit_trust$Sigma), r),
                           W = fit_trust$W)

# Create prediction data
n_pred <- 1e4
X_new <- matrix(0, nrow = n_pred * r, ncol= r * (p + 1))
counter <- 1
for(jj in 1:n_pred){
  for(kk in 1:r){
    X_new[counter, ((kk - 1) * (p + 1) + 1):(kk * (p + 1))] <-
      c(1, runif(p, -1, 1))
    counter <- counter + 1
  }
}
Y_new <- lvmmrPQL::generate_lvmmr(X = X_new, Beta = Beta_true, R = chol(Sigma_true),
                    type = type, psi = psi_true)

# Get GLM Fit
unique_types <- unique(type)
uni_coefs <- matrix(0, ncol = length(unique_types), nrow = r * (p + 1))
for(ii in 1:length(unique_types)){
  fam <- c("gaussian", "binomial", "quasipoisson")[unique_types[ii]]
  y_uni <- c(Y[, type == unique_types[ii]])
  X_uni <- X[rep(type == unique_types[ii], n), ]
  glm_fit <- stats::glm(y_uni ~ 0 + X_uni, family = fam)
  uni_coefs[, ii] <- stats::coef(glm_fit)
}
Beta_GLM <- apply(uni_coefs, 1, mean, na.rm = T)

Xb_GLM <- matrix(X_new %*% Beta_GLM, nrow = n_pred, ncol = r, byrow = T)
pred_GLM <- t(lvmmrPQL:::get_cumulant_diffs(t(Xb_GLM), type, 1))

# We win.
pred_trust <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = fit_trust$Beta,
                                          sigma = sqrt(diag(fit_trust$Sigma)),
                                          type = type,
                                          num_nodes = 15)
pred_pgd <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = fit_pgd$Beta,
                                          sigma = sqrt(diag(fit_pgd$Sigma)),
                                          type = type,
                                          num_nodes = 15)
pred_diag <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = fit_diag$Beta,
                                          sigma = sqrt(diag(fit_diag$Sigma)),
                                          type = type,
                                          num_nodes = 15)
pred_oracle <- lvmmrPQL::predict_lvmmr(X = X_new,
                                          Beta = Beta_true,
                                          sigma = sqrt(diag(Sigma_true)),
                                          type = type,
                                          num_nodes = 15)

get_rmse <- function(x){sqrt(colMeans((x - Y_new)^2))}
RMSE <- rbind(get_rmse(pred_trust), get_rmse(pred_pgd), get_rmse(pred_diag), 
      get_rmse(pred_GLM))
RMSE <- t(t(RMSE) / get_rmse(pred_oracle))
rownames(RMSE) <- c("Trust", "PGD", "Indep.", "GLM")
RMSE
```

<!-- # Testing -->

<!-- We first check that the test has approximately correct size for normal responses, in which case the test should be asymptotically correct since the PQL approximation of the likelihood function is exact. -->

<!-- ```{r} -->
<!-- library(parallel) -->
<!-- do_test_experiment <- function(xxx){ -->
<!--   set.seed(xxx) -->
<!--   n <- 100 -->
<!--   type <- c(1, 3) -->
<!--   r <- length(type) -->

<!--   # Each observation has its own intercept -->
<!--   X <- Matrix::kronecker(rep(1, n), diag(r)) -->
<!--   Beta_true <- seq(-0.5, 0.5, length.out = r) -->

<!--   # H0 -->
<!--   #Sigma_true <- diag(1, r) -->
<!--   # HA -->
<!--   Sigma_true <- matrix(0.5, r, r) -->
<!--   diag(Sigma_true) <- 1 -->
<!--   psi_true <- rep(0.1, r) -->

<!--   Y <- lvmmrPQL::generate_lvmmr(X = X, Beta = Beta_true, R = chol(Sigma_true), -->
<!--                       type = type, psi = psi_true) -->


<!-- MU <- diag(NA, r, r) -->
<!-- diag(MU)[type == 2] <-1 -->
<!-- # Null model no intercept for first obs -->
<!-- fit_null <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = MU, -->
<!--                            relative = T, -->
<!--                            quiet = c(T, T, T, T), -->
<!--                            maxit = c(100, 100, 500, 100), -->
<!--                            tol = c(1e-12, 1e-8, 1e-10, 1e-8), -->
<!--                            psi = psi_true, -->
<!--                            pgd = FALSE) -->
<!-- MR <- matrix(NA, r, r) -->
<!-- diag(MR)[type == 2] <-1 -->
<!-- fit_full <- lvmmrPQL::lvmmr_PQL(Y = Y, X = X, type = type, M = MR, -->
<!--                            relative = T, -->
<!--                            quiet = c(T, T, T, T), -->
<!--                            maxit = c(100, 100, 500, 0), -->
<!--                            tol = c(1e-12, 1e-8, 1e-10, 1e-8), -->
<!--                            psi = psi_true, -->
<!--                            Beta = fit_null$Beta, -->
<!--                            Sigma = fit_null$Sigma, -->
<!--                            W = fit_null$W, -->
<!--                            pgd = FALSE) -->
<!-- df <- sum(is.na(MR[lower.tri(MR, diag = T)])) - sum(is.na(MU[lower.tri(MR, diag = T)]))  -->
<!-- p_val <- pchisq(q = -2 * (fit_full$obj - fit_null$obj), -->
<!--               df = df, lower.tail = FALSE) -->
<!-- return(p_val) -->
<!-- } -->

<!-- cl <- makeCluster(getOption("cl.cores", 8)) -->
<!-- p_vals <-parSapply(cl, 1:1000, do_test_experiment) -->
<!-- ``` -->

